# Архітектура сервісу "Tempo" (Task Manager API)

Цей документ надає огляд логічної структури, моделі даних та ключових сценаріїв взаємодії для бекенд-додатку **"Tempo"**.

---

## 1. Архітектурний огляд (Модульна структура)

Проєкт "Tempo" побудований на принципах тришарової архітектури, що забезпечує чіткий **поділ відповідальності** (Separation of Concerns), незалежність бізнес-логіки від протоколу (HTTP) та легкість тестування.

### Компоненти та їх взаємодія

| Модуль           | Шар             | Відповідальність                                                                                         | Взаємодія                         |
| :--------------- | :-------------- | :------------------------------------------------------------------------------------------------------- | :-------------------------------- |
| **Controllers**  | Представлення   | Обробка вхідних HTTP-запитів, валідація, формування відповіді клієнту (200 OK, 400 Bad Request і т.д.).  | Викликає методи **Services**.     |
| **Services**     | Бізнес-логіка   | Імплементація всіх правил, перевірок та бізнес-процесів (наприклад, фільтрація, сортування, транзакції). | Викликає методи **Repositories**. |
| **Repositories** | Доступ до даних | Абстрагує роботу з конкретною базою даних. Виконує базові CRUD-операції.                                 | Взаємодіє з **Базою Даних**.      |

---

## 2. Модель даних (Сутності та зв'язки)

Система оперує двома основними сутностями: **Task** та **Category**. Вони пов'язані між собою зв'язком **Багато-до-Багатьох (Many-to-Many)**.

### Схема сутностей (ER-модель)

| Сутність         | Основні Поля                                           | Примітки                                                                                   |
| :--------------- | :----------------------------------------------------- | :----------------------------------------------------------------------------------------- |
| **Task**         | `id`, `title`, `description`, `dueDate`, `isCompleted` | **Завдання** є основною одиницею системи. `isCompleted` є ключовим для керування статусом. |
| **Category**     | `id`, `name`                                           | **Категорії** використовуються для організації та фільтрації завдань.                      |
| **TaskCategory** | `taskId`, `categoryId`                                 | Проміжна таблиця для реалізації зв'язку Many-to-Many.                                      |

---

## 3. Опис ключового сценарію: Оновлення статусу завдання

Як приклад, розглянемо потік даних при **позначенні завдання як виконаного** (наприклад, через `PUT /tasks/{id}/complete`).

| Етап                  | Компонент      | Дія та Бізнес-Правила                                                                                                                                        | Оновлення Даних             |
| :-------------------- | :------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------- |
| **1. Вхідний запит**  | **Controller** | Приймає HTTP-запит з ID завдання.                                                                                                                            | Передає ID до **Service**.  |
| **2. Обробка логіки** | **Service**    | 1. Запитує **Repository** для отримання поточного завдання. 2. Перевіряє, чи завдання вже не виконано (бізнес-правило). 3. Викликає метод оновлення статусу. | Перевірка цілісності даних. |
| **3. Збереження**     | **Repository** | Формує запит до БД для зміни `isCompleted` на `true` та оновлення поля `updatedAt`.                                                                          | **Task** оновлюється в БД.  |
| **4. Фінал**          | **Controller** | Повертає клієнту успішну відповідь (200 OK) з оновленим об'єктом Task.                                                                                       | Немає.                      |
