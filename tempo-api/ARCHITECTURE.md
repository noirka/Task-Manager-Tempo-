# Архітектура сервісу "Tempo" (Task Manager API)

Цей документ надає огляд логічної структури, моделі даних та ключових сценаріїв взаємодії для бекенд-додатку **"Tempo"**.

---

## 1. Архітектурний огляд та Модульна Структура

Проєкт "Tempo" побудований на принципах тришарової архітектури, яка була **модифікована під Модульну Архітектуру** з виділенням ядра системи в незалежну бібліотеку. Це забезпечує **поділ відповідальності** (Separation of Concerns), незалежність бізнес-логіки від протоколу (HTTP) та легкість тестування.

### Компоненти та Їх Взаємодія

Ключова бізнес-логіка виділена в окрему бібліотеку `@tempo-api/task-service`.

| Компонент        | Шар / Пакет                 | Відповідальність та Принципи                                                                                                                                                               |
| :--------------- | :-------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Controllers**  | Представлення (API Gateway) | Обробка вхідних HTTP-запитів, валідація, формування відповіді клієнту (200 OK, 400 Bad Request). Викликає методи **Services**.                                                             |
| **Services**     | Бізнес-логіка (Ядро)        | Імплементація всіх правил, перевірок та бізнес-процесів (фільтрація, сортування). Цей шар використовує принцип **Інверсії Керування (IoC)**, отримуючи **Repositories** через конструктор. |
| **Repositories** | Доступ до даних (Ядро)      | Абстрагує роботу з конкретною базою даних. Виконує базові CRUD-операції.                                                                                                                   |

**Принцип IoC (Впровадження Залежностей):**
Для забезпечення максимальної гнучкості та тестування, **TaskService** не створює **MongoTaskRepository** самостійно, а отримує його як залежність через інтерфейс `ITaskRepository`. Це дозволяє:

1. Легко замінювати базу даних (наприклад, на SQL-репозиторій).
2. Використовувати тестові моки (заглушки) для `ITaskRepository` під час юніт-тестування **TaskService**.

---

## 2. Модель даних (Сутності та зв'язки)

Система оперує двома основними сутностями: **Task** та **Category**. Вони пов'язані між собою зв'язком **Багато-до-Багатьох (Many-to-Many)**.

### Схема сутностей (ER-модель)

| Сутність         | Основні Поля                                                         | Примітки                                                                                                                                                               |
| :--------------- | :------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Task**         | `id`, `title`, `description`, `dueDate`, `isCompleted`, **`userId`** | **Завдання** є основною одиницею системи. **Поле `userId` було додано** для прив'язки завдання до користувача, що стало результатом виправлення критичного "ботлнеку". |
| **Category**     | `id`, `name`                                                         | **Категорії** використовуються для організації та фільтрації завдань.                                                                                                  |
| **TaskCategory** | `taskId`, `categoryId`                                               | Проміжна таблиця для реалізації зв'язку Many-to-Many.                                                                                                                  |

---

## 3. Опис ключового сценарію: Оновлення статусу завдання

Як приклад, розглянемо потік даних при **позначенні завдання як виконаного** (наприклад, через `PUT /tasks/{id}/complete`).

| Етап                  | Компонент      | Дія та Бізнес-Правила                                                                                                                                        | Оновлення Даних             |
| :-------------------- | :------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------- |
| **1. Вхідний запит**  | **Controller** | Приймає HTTP-запит з ID завдання.                                                                                                                            | Передає ID до **Service**.  |
| **2. Обробка логіки** | **Service**    | 1. Запитує **Repository** для отримання поточного завдання. 2. Перевіряє, чи завдання вже не виконано (бізнес-правило). 3. Викликає метод оновлення статусу. | Перевірка цілісності даних. |
| **3. Збереження**     | **Repository** | Формує запит до БД для зміни `isCompleted` на `true` та оновлення поля `updatedAt`.                                                                          | **Task** оновлюється в БД.  |
| **4. Фінал**          | **Controller** | Повертає клієнту успішну відповідь (200 OK) з оновленим об'єктом Task.                                                                                       | Немає.                      |
